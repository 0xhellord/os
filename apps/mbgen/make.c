/*++

Copyright (c) 2016 Minoca Corp. All Rights Reserved

Module Name:

    make.c

Abstract:

    This module implements output support for Make in the Minoca Build
    Generator.

Author:

    Evan Green 8-Feb-2015

Environment:

    Build

--*/

//
// ------------------------------------------------------------------- Includes
//

#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mbgen.h"

//
// ---------------------------------------------------------------- Definitions
//

#define MBGEN_MAKE_VARIABLE "$(%s)"
#define MBGEN_MAKE_NEWLINE " \\\n        "
//
// ------------------------------------------------------ Data Type Definitions
//

//
// ----------------------------------------------- Internal Function Prototypes
//

VOID
MbgenMakePrintTargetFile (
    FILE *File,
    PMBGEN_CONTEXT Context,
    PMBGEN_TARGET Target
    );

VOID
MbgenMakePrintSource (
    FILE *File,
    PMBGEN_CONTEXT Context,
    PMBGEN_TARGET Target,
    PSTR Source
    );

VOID
MbgenMakePrintConfig (
    FILE *File,
    PMBGEN_CONTEXT Context,
    PCHALK_OBJECT Config
    );

//
// -------------------------------------------------------------------- Globals
//

//
// ------------------------------------------------------------------ Functions
//

INT
MbgenCreateMakefile (
    PMBGEN_CONTEXT Context
    )

/*++

Routine Description:

    This routine creates a Makefile out of the build graph.

Arguments:

    Context - Supplies a pointer to the application context.

Return Value:

    0 on success.

    Returns an error number on failure.

--*/

{

    PLIST_ENTRY CurrentEntry;
    FILE *File;
    UINTN Index;
    PSTR MakefilePath;
    PMBGEN_SCRIPT Script;
    PLIST_ENTRY ScriptEntry;
    INT Status;
    PMBGEN_TARGET Target;
    time_t Time;
    PMBGEN_TOOL Tool;

    File = NULL;
    MakefilePath = MbgenAppendPaths(Context->BuildRoot, "Makefile");
    if (MakefilePath == NULL) {
        Status = ENOMEM;
        goto CreateMakefileEnd;
    }

    if ((Context->Options & MBGEN_OPTION_VERBOSE) != 0) {
        printf("Creating %s\n", MakefilePath);
    }

    File = fopen(MakefilePath, "w");
    if (File == NULL) {
        Status = errno;
        fprintf(stderr,
                "Error: Failed to open %s: %s\n",
                MakefilePath,
                strerror(Status));

        goto CreateMakefileEnd;
    }

    Time = time(NULL);
    fprintf(File,
            "# Makefile automatically generated by mbgen at %s\n",
            ctime(&Time));

    fprintf(File, "# Define high level variables\n");
    fprintf(File, "SOURCE_ROOT := %s\n", Context->SourceRoot);
    fprintf(File, "BUILD_ROOT := %s\n\n", Context->BuildRoot);
    fprintf(File, "# Define tools\n");
    CurrentEntry = Context->ToolList.Next;
    while (CurrentEntry != &(Context->ToolList)) {
        Tool = LIST_VALUE(CurrentEntry, MBGEN_TOOL, ListEntry);
        fprintf(File,
                "TOOL_%s := @echo \"%s\" ; \\\n"
                "    %s\n\n",
                Tool->Name,
                Tool->Description,
                Tool->Command);

        CurrentEntry = CurrentEntry->Next;
    }

    //
    // Loop over every script (file) in the build.
    //

    fprintf(File, "\n# Define targets\n\n");
    ScriptEntry = Context->ScriptList.Next;
    while (ScriptEntry != &(Context->ScriptList)) {
        Script = LIST_VALUE(ScriptEntry, MBGEN_SCRIPT, ListEntry);
        ScriptEntry = ScriptEntry->Next;
        if (LIST_EMPTY(&(Script->TargetList))) {
            continue;
        }

        //
        // Loop over every target defined in the script.
        //

        fprintf(File, "# Define targets for %s\n", Script->Path);
        CurrentEntry = Script->TargetList.Next;
        while (CurrentEntry != &(Script->TargetList)) {
            Target = LIST_VALUE(CurrentEntry, MBGEN_TARGET, ListEntry);
            CurrentEntry = CurrentEntry->Next;
            if ((Target->Flags & MBGEN_TARGET_PHONY) != 0) {
                fprintf(File, ".PHONY: ");
                MbgenMakePrintTargetFile(File, Context, Target);
                fprintf(File, "\n");
            }

            MbgenMakePrintTargetFile(File, Context, Target);
            fprintf(File, ": ");

            //
            // Add the sources.
            //

            for (Index = 0; Index < Target->Sources.Count; Index += 1) {
                fprintf(File, MBGEN_MAKE_NEWLINE);
                MbgenMakePrintSource(File,
                                     Context,
                                     Target,
                                     Target->Sources.Strings[Index]);
            }

            //
            // Add the dependencies.
            //

            for (Index = 0; Index < Target->Deps.Count; Index += 1) {
                fprintf(File, MBGEN_MAKE_NEWLINE);
                MbgenMakePrintTargetFile(File,
                                         Context,
                                         Target->Deps.List[Index]);
            }

            //
            // Add the configs.
            //

            if (Target->Config != NULL) {
                MbgenMakePrintConfig(File, Context, Target->Config);
            }

            //
            // Use the tool to make the target.
            //

            if (Target->Tool != NULL) {
                fprintf(File,
                        "\n\t$(TOOL_%s)\n\n",
                        Target->Tool);

            } else {
                fprintf(File, "\n\n");
            }
        }
    }

    Status = 0;

CreateMakefileEnd:
    if (File != NULL) {
        fclose(File);
    }

    if (MakefilePath != NULL) {
        free(MakefilePath);
    }

    return Status;
}

//
// --------------------------------------------------------- Internal Functions
//

VOID
MbgenMakePrintTargetFile (
    FILE *File,
    PMBGEN_CONTEXT Context,
    PMBGEN_TARGET Target
    )

/*++

Routine Description:

    This routine prints a target's output file name.

Arguments:

    File - Supplies a pointer to the file to print to.

    Context - Supplies a pointer to the application context.

    Target - Supplies a pointer to the target to print.

Return Value:

    None.

--*/

{

    PMBGEN_SCRIPT Script;

    Script = Target->Script;
    if ((Target->Flags & MBGEN_TARGET_PHONY) != 0) {
        fprintf(File, "%s", Target->Output);
        return;
    }

    switch (Script->Root) {
    case MbgenSourceTree:
        fprintf(File, MBGEN_MAKE_VARIABLE, "SOURCE_ROOT");
        break;

    case MbgenBuildTree:
        fprintf(File, MBGEN_MAKE_VARIABLE, "BUILD_ROOT");
        break;

    case MbgenAbsolutePath:
        break;

    default:

        assert(FALSE);

        break;
    }

    fprintf(File, "/%s/%s", Script->Path, Target->Output);
    return;
}

VOID
MbgenMakePrintSource (
    FILE *File,
    PMBGEN_CONTEXT Context,
    PMBGEN_TARGET Target,
    PSTR Source
    )

/*++

Routine Description:

    This routine prints a target's output file name.

Arguments:

    File - Supplies a pointer to the file to print to.

    Context - Supplies a pointer to the application context.

    Target - Supplies a pointer to the current target.

    Source - Supplies a pointer to the source file.

Return Value:

    None.

--*/

{

    if (MBGEN_IS_SOURCE_ROOT_RELATIVE(Source)) {
        fprintf(File, MBGEN_MAKE_VARIABLE, "SOURCE_ROOT");
        Source += 2;

    } else if (MBGEN_IS_BUILD_ROOT_RELATIVE(Source)) {
        fprintf(File, MBGEN_MAKE_VARIABLE, "BUILD_ROOT");
        Source += 2;

    } else if (*Source == '^') {
        fprintf(File,
                MBGEN_MAKE_VARIABLE "/%s",
                "BUILD_ROOT",
                Target->Script->Path);

        Source += 1;

    } else if (*Source == '/') {
        Source += 1;

    } else {
        fprintf(File,
                MBGEN_MAKE_VARIABLE "/%s",
                "SOURCE_ROOT",
                Target->Script->Path);
    }

    fprintf(File, "/%s", Source);
    return;
}

VOID
MbgenMakePrintConfig (
    FILE *File,
    PMBGEN_CONTEXT Context,
    PCHALK_OBJECT Config
    )

/*++

Routine Description:

    This routine prints a target's configuration dictionary.

Arguments:

    File - Supplies a pointer to the file to print to.

    Context - Supplies a pointer to the application context.

    Config - Supplies a pointer to the configuration to print.

Return Value:

    None.

--*/

{

    PLIST_ENTRY CurrentEntry;
    PCHALK_DICT_ENTRY Entry;
    PCHALK_OBJECT Value;

    assert(Config->Header.Type == ChalkObjectDict);

    CurrentEntry = Config->Dict.EntryList.Next;
    while (CurrentEntry != &(Config->Dict.EntryList)) {
        Entry = LIST_VALUE(CurrentEntry, CHALK_DICT_ENTRY, ListEntry);
        CurrentEntry = CurrentEntry->Next;
        Value = Entry->Value;
        if (Entry->Key->Header.Type != ChalkObjectString) {
            fprintf(stderr,
                    "Error: Skipping config object with non-string key.\n");

            continue;
        }

        if ((Value->Header.Type != ChalkObjectString) &&
            (Value->Header.Type != ChalkObjectInteger)) {

            fprintf(stderr,
                    "Error: Skipping config key %s: unsupported type.\n",
                    Entry->Key->String.String);

            continue;
        }

        fprintf(File, MBGEN_MAKE_NEWLINE);
        fprintf(File, "%s=", Entry->Key->String.String);
        if (Value->Header.Type == ChalkObjectInteger) {
            fprintf(File, "%lld", Value->Integer.Value);

        } else if (Value->Header.Type == ChalkObjectString) {
            fprintf(File, "%s", Value->String.String);
        }
    }

    return;
}

