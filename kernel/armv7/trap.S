/*++

Copyright (c) 2012 Minoca Corp. All Rights Reserved

Module Name:

    trap.S

Abstract:

    This module implements interrupt and exception trap management, such as
    saving and restoring registers.

Author:

    Evan Green 11-Aug-2012

Environment:

    Kernel mode

--*/

##
## ------------------------------------------------------------------- Includes
##

#include <minoca/kernel/arm.inc>

##
## ---------------------------------------------------------------- Definitions
##

##
## ---------------------------------------------------------------------- Code
##

ASSEMBLY_FILE_HEADER

##
## VOID
## ArpInitializeExceptionStacks (
##     PVOID ExceptionStacksBase,
##     ULONG ExceptionStackSize
##     )
##

/*++

Routine Description:

    This routine initializes the stack pointer for all privileged ARM modes. It
    switches into each mode and initializes the banked r13. This function
    should be called with interrupts disabled and returns with interrupts
    disabled.

Arguments:

    ExceptionStacksBase - Supplies a pointer to the lowest address that should
        be used for exception stacks. Each stack takes up 16 bytes and there are
        4 modes, so at least 64 bytes are needed.

    ExceptionStackSize - Supplies the size of each exception stack.

Return Value:

    None.

--*/

FUNCTION ArpInitializeExceptionStacks

    ##
    ## Load R1 with an individual stack size.
    ##

    add     %r0, %r0, %r1

    ##
    ## Disable interrupts and switch into IRQ mode. Note that this also
    ## clobbers the flags register.
    ##

    mov     %r2, #(PSR_FLAG_IRQ | ARM_MODE_IRQ)
    msr     CPSR_cxsf, %r2
    mov     %sp, %r0
    add     %r0, %r0, %r1

    ##
    ## Initialize the FIQ stack.
    ##

    mov     %r2, #(PSR_FLAG_IRQ | ARM_MODE_FIQ)
    msr     CPSR_cxsf, %r2
    mov     %sp, %r0
    add     %r0, %r0, %r1

    ##
    ## Initialize the undefined instruction stack.
    ##

    mov     %r2, #(PSR_FLAG_IRQ | ARM_MODE_UNDEF)
    msr     CPSR_cxsf, %r2
    mov     %sp, %r0
    add     %r0, %r0, %r1

    ##
    ## Initialize the data fetch abort stack.
    ##

    mov     %r2, #(PSR_FLAG_IRQ | ARM_MODE_ABORT)
    msr     CPSR_cxsf, %r2
    mov     %sp, %r0

    ##
    ## Switch back to SVC mode and return.
    ##

    mov     %r2, #(PSR_FLAG_IRQ | ARM_MODE_SVC)
    msr     CPSR_cxsf, %r2
    bx      %lr

END_FUNCTION ArpInitializeExceptionStacks

##
## VOID
## ArpUndefinedInstructionEntry (
##     VOID
##     )
##

/*++

Routine Description:

    This routine directly handles an exception generated by an undefined
    instruction. It uses a largely separate code path from normal exceptions
    to avoid recursively breaking into the debugger.

Arguments:

    None.

Return Value:

    None.

--*/

FUNCTION ArpUndefinedInstructionEntry

    ##
    ## Save state and create a trap frame.
    ##

    ARM_ENTER_INTERRUPT

    ##
    ## Call the main dispatch routine routine with a pointer to the trap frame
    ## as the only parameter. Align the stack down even though it shouldn't be
    ## strictly necessary in case something bad happened.
    ##

    mov     %r0, %sp
    mov     %r4, %sp
    and     %r1, %r4, #0xFFFFFFF0       @ Align stack down for fear of badness.
    mov     %sp, %r1
    bl      KeDispatchUndefinedInstructionException
    mov     %sp, %r4

    ##
    ## Restore state and return.
    ##

    ARM_EXIT_INTERRUPT

END_FUNCTION ArpUndefinedInstructionEntry

##
## INTN
## ArpSoftwareInterruptEntry (
##     VOID
##     )
##

/*++

Routine Description:

    This routine directly handles an exception generated by a software
    interrupt (a system call).

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or positive integer on success.

    Error status code on failure.

--*/

FUNCTION ArpSoftwareInterruptEntry
    srsdb   %sp!, #ARM_MODE_SVC                 @ Push lr and spsr.
    tst     %r2, %r2                            @ See if "full" is zero.
    bne     ArpSoftwareInterruptEntrySlow       @ Go to slow path if non-zero.
    sub     %sp, #(TRAP_FRAME_SIZE - 8)         @ Make space for rest of frame.
    mov     %r3, %sp                            @ Get stack.
    cps     #ARM_MODE_SYSTEM                    @ Switch to system mode.
    str     %lr, [%r3, #TRAP_USERLR]            @ Save usermode SP.
    str     %sp, [%r3, #TRAP_USERSP]            @ Save usermode LR.
    cpsie   i, #ARM_MODE_SVC                    @ Enable interrupts, svc mode.

    ##
    ## Save the R0 and R1, as they hold the system call parameters that will be
    ## needed if the system call gets restarted.
    ##

    str     %r0, [%sp, #TRAP_R0]
    str     %r1, [%sp, #TRAP_R1]

    ##
    ## Set the exception CPSR to something wild as a hint that this trap frame
    ## is incomplete.
    ##

    mov     %r3, #0xFFFFFFFF                    @ Create -1.
    str     %r3, [%sp, #TRAP_EXCEPTION_CPSR]    @ Save into exception CPSR.

    ##
    ## The system call routine takes three parameters: the system call number,
    ## system call parameter, and a pointer to the trap frame. User-mode already
    ## set up the first two parameters in R0 and R1, and they were preserved
    ## throughout the context save process here. So all that's left is to put a
    ## pointer to the trap frame in R2.
    ##

    mov     %r2, %sp                            @ Set trap frame parameter.
    bl      KeSystemCallHandler                 @ Handle system call.

    ##
    ## Determine whether or not a signal is pending on the thread.
    ## KeGetCurrentThread uses R0, R1, and R2. Save the system call's return
    ## value in R3, so that it is not lost. It cannot be saved in the trap
    ## frame as the saved R0 and R1 hold the parameters needed to dispatch
    ## a signal.
    ##

    mov     %r3, %r0                             @ Save the return value.
    bl      KeGetCurrentThread                   @ Get current thread in R0.
    ldr     %r1, [%r0, #THREAD_SIGNAL_PENDING]   @ Load signal pending status.
    mov     %r0, %r3                             @ Restore return value.
    cbnz    %r1, ArpSoftwareInterruptFastSignal  @ Jump to dispatch signal.

    ##
    ## Restore the user mode stack and link registers. Do not restore or
    ## clobber R0 as it holds the system call's return value.
    ##

    mov     %r1, %sp                            @ Get SVC stack pointer.
    cpsid   i, #ARM_MODE_SYSTEM                 @ Switch to system mode.
    ldr     %sp, [%r1, #TRAP_USERSP]            @ Restore usermode SP.
    ldr     %lr, [%r1, #TRAP_USERLR]            @ Restore usermode LR.
    cpsid   i, #ARM_MODE_SVC                    @ Switch back to svc mode.
    add     %sp, #(TRAP_FRAME_SIZE - 8)         @ Pop up to PC/Cpsr.

    ##
    ## Clear the volatile registers to avoid leaking kernel state. Do not clear
    ## R0 as it holds the system call's return value.
    ##

    eor     %r1, %r1
    eor     %r2, %r2
    eor     %r3, %r3
    eor     %r12, %r12
    rfeia   %sp!                                @ Restore PC and CPSR. Bye!

    ##
    ## Save the full trap frame. The CPSR, PC, user SP, user LR, R0, and R1 are
    ## the only values saved in the trap frame.
    ##

ArpSoftwareInterruptFastSignal:
    eor     %lr, %lr                             @ Zero SVC link register.
    eor     %r12, %r12                           @ Zero volatile R12.
    eor     %r3, %r3                             @ Zero volatile R3.
    eor     %r2, %r2                             @ Zero volatile R2.
    add     %r1, %sp, #TRAP_PC                   @ Get location after SVC LR.
    stmdb   %r1!, {%r2-%r12, %lr}                @ Push general registers.
    mrs     %r1, cpsr                            @ Get the "exception" CPSR.
    str     %r1, [%sp, #TRAP_EXCEPTION_CPSR]     @ Save the "exception" CPSR.
    str     %sp, [%sp]                           @ Save SP.
    b       ArpSoftwareInterruptSlowSignal

    ##
    ## Perform the slow version of the system call that builds up a complete
    ## trap frame. This is used for system calls like fork and exec, where the
    ## trap frame is used in the system call.
    ##

ArpSoftwareInterruptEntrySlow:
    mov     %lr, #0                              @ Zero SVC link register.
    stmdb   %sp!, {%r1-%r12, %lr}                @ Push general registers.
    mrs     %r2, cpsr                            @ Get the "exception" CPSR.
    stmdb   %sp!, {%r0, %r2}                     @ Push exception CPSR and R0.
    sub     %sp, #TRAP_R0                        @ Account for pushes.
    mov     %r4, %sp                             @ Get stack.
    cps     #ARM_MODE_SYSTEM                     @ Switch to system mode.
    str     %lr, [%r4, #TRAP_USERLR]             @ Save usermode SP.
    str     %sp, [%r4, #TRAP_USERSP]             @ Save usermode LR.
    cpsie   i, #ARM_MODE_SVC                     @ Enable interrupts, svc mode.
    str     %sp, [%sp]                           @ Save SP.

    ##
    ## Just like in the fast case, R0 and R1 are preserved as the first two
    ## parameters. Set the trap frame parameter and return.
    ##

    mov     %r2, %sp
    bl      KeSystemCallHandler

    ##
    ## Determine whether or not a signal is pending on the thread.
    ## KeGetCurrentThread uses R0, R1, and R2. Save the system call's return
    ## value in R3, so that it is not lost. It cannot be saved in the trap
    ## frame as the saved R0 and R1 hold the parameters needed to dispatch
    ## a signal.
    ##

    mov     %r3, %r0                             @ Save the return value.
    bl      KeGetCurrentThread                   @ Get current thread in R0.
    ldr     %r1, [%r0, #THREAD_SIGNAL_PENDING]   @ Load signal pending status.
    mov     %r0, %r3                             @ Restore the return value.
    cbz     %r1, ArpSoftwareInterruptEntrySlowEnd  @ Jump to the end if 0.

    ##
    ## Restore the parameters for the signal dispatcher.
    ##

ArpSoftwareInterruptSlowSignal:
    ldr     %r1, [%sp, #TRAP_R0]
    ldr     %r2, [%sp, #TRAP_R1]
    mov     %r3, %sp

    ##
    ## Store the return value in the trap frame now in case the signal wants to
    ## modify it and then put it back in R0 after the signal is dispatched.
    ##

    str     %r0, [%sp, #TRAP_R0]
    bl      PsDispatchPendingSignalsOnCurrentThread
    ldr     %r0, [%sp, #TRAP_R0]

    ##
    ## Restore the stack pointer. The rest of the context better be at the new
    ## stack location. Then restore the user mode sp and lr.
    ##

ArpSoftwareInterruptEntrySlowEnd:
    ldr     %sp, [%sp]                          @ Restore stack pointer.
    add     %sp, %sp, #4                        @ Pop stack pointer.

    ##
    ## Restore the user mode stack and link registers. Do not restore or
    ## clobber R0 as it holds the system call's return value.
    ##

    mov     %r1, %sp                            @ Get SVC stack pointer.
    cpsid   i, #ARM_MODE_SYSTEM                 @ Switch to system mode.
    ldr     %sp, [%r1]                          @ Restore usermode SP.
    ldr     %lr, [%r1, #4]                      @ Resotre usermode LR.
    cpsid   i, #ARM_MODE_SVC                    @ Switch back to svc mode.
    add     %sp, %sp, #16                       @ Pop up to R1.
    ldmia   %sp!, {%r1-%r12, %lr}               @ Restore general registers.
    rfeia   %sp!                                @ Restore PC and CPSR.

END_FUNCTION ArpSoftwareInterruptEntry

##
## VOID
## ArpPrefetchAbortEntry (
##     VOID
##     )
##

/*++

Routine Description:

    This routine directly handles an exception generated by a prefetch abort
    (page fault).

Arguments:

    None.

Return Value:

    None.

--*/

FUNCTION ArpPrefetchAbortEntry

    ##
    ## In ARM mode, prefect aborts save the PC-4 in LR. For Thumb mode, data
    ## aborts save the PC in LR. Thus, the PC is always 4 bytes head of the
    ## faulting address.
    ##

    sub     %lr, %lr, #4                @ Prefetches go too far by 4.

    ##
    ## Save state and create a trap frame.
    ##

    ARM_ENTER_INTERRUPT

    ##
    ## Call the main dispatch routine routine with a pointer to the trap frame
    ## and 1 to indicate a prefetch abort.
    ##

    mov     %r0, %sp
    mov     %r1, #1
    blx     KeDispatchException

    ##
    ## Restore state and return.
    ##

    ARM_EXIT_INTERRUPT

END_FUNCTION ArpPrefetchAbortEntry

##
## VOID
## ArpDataAbortEntry (
##     VOID
##     )
##

/*++

Routine Description:

    This routine directly handles an exception generated by a data abort (page
    fault).

Arguments:

    None.

Return Value:

    None.

--*/

FUNCTION ArpDataAbortEntry

    ##
    ## In ARM mode, data aborts save the PC in LR. For Thumb mode, data aborts
    ## save the PC+4 in LR. Thus, the PC is always 8 bytes head of the faulting
    ## address.
    ##

    sub     %lr, %lr, #8

    ##
    ## Save state and create a trap frame.
    ##

    ARM_ENTER_INTERRUPT

    ##
    ## Call the main dispatch routine routine with a pointer to the trap frame
    ## and 0 to indicate a prefetch abort.
    ##

    mov     %r0, %sp
    mov     %r1, #0
    blx     KeDispatchException

    ##
    ## Restore state and return.
    ##

    ARM_EXIT_INTERRUPT

END_FUNCTION ArpDataAbortEntry

##
## VOID
## ArpIrqEntry (
##     VOID
##     )
##

/*++

Routine Description:

    This routine directly handles an exception generated by an external
    interrupt on the IRQ pin.

Arguments:

    None.

Return Value:

    None.

--*/

FUNCTION ArpIrqEntry
    b       ArpCommonInterruptEntry

END_FUNCTION ArpIrqEntry

##
## VOID
## ArpFiqEntry (
##     VOID
##     )
##

/*++

Routine Description:

    This routine directly handles an exception generated by an external
    interrupt on the FIQ pin.

Arguments:

    None.

Return Value:

    None.

--*/

FUNCTION ArpFiqEntry
    b       ArpCommonInterruptEntry

END_FUNCTION ArpFiqEntry

##
## --------------------------------------------------------- Internal Functions
##

##
## This code is entered as the result of any interrupt or exception. Its job is
## to transition back to the SVC stack and then call the real interrupt
## dispatch routine.
##

ArpCommonInterruptEntry:

    ##
    ## Save state and create a trap frame.
    ##

    ARM_ENTER_INTERRUPT

    ##
    ## Call the main dispatch routine routine with a pointer to the trap frame
    ## as the only parameter. Align the stack down in case the exception
    ## interrupted something unaligned.
    ##

    mov     %r0, %sp
    mov     %r4, %sp
    and     %r5, %r4, #0xFFFFFFF0
    mov     %sp, %r5
    bl      KeDispatchException
    mov     %sp, %r4

    ##
    ## Restore state and return.
    ##

    ARM_EXIT_INTERRUPT

